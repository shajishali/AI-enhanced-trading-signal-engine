#!/usr/bin/env python3
"""
Separate Backtesting Signals

This script separates backtesting signals from real trading signals
by adding a source field and filtering them out of the main signals page.
"""

import os
import sys
import django
from datetime import datetime

# Setup Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ai_trading_engine.settings')
django.setup()

from apps.signals.models import TradingSignal
from django.db import transaction, models
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def mark_backtesting_signals():
    """Mark existing backtesting signals so they can be filtered out"""
    print("ğŸ·ï¸ Marking backtesting signals...")
    
    with transaction.atomic():
        # Mark signals that were generated by backtesting
        backtesting_signals = TradingSignal.objects.filter(
            metadata__contains={'signal_source': 'BACKTESTING'}
        ).update(
            metadata=models.F('metadata') | {'is_backtesting': True}
        )
        
        # Also mark signals with specific entry_point_type that indicates backtesting
        backtesting_signals += TradingSignal.objects.filter(
            entry_point_type__in=['FALLBACK', 'BACKTESTING']
        ).update(
            metadata=models.F('metadata') | {'is_backtesting': True}
        )
        
        # Mark signals created by the strategy backtesting service
        backtesting_signals += TradingSignal.objects.filter(
            notes__icontains='Generated signal for'
        ).update(
            metadata=models.F('metadata') | {'is_backtesting': True}
        )
        
        print(f"âœ… Marked {backtesting_signals} signals as backtesting signals")


def update_signal_views():
    """Update the signal views to exclude backtesting signals"""
    print("ğŸ”§ Updating signal views...")
    
    # Read the current views file
    with open('apps/signals/views.py', 'r') as f:
        content = f.read()
    
    # Update signal_dashboard to exclude backtesting signals
    old_query = '''# Get recent signals with related data
        recent_signals = TradingSignal.objects.select_related('symbol', 'signal_type').filter(is_valid=True).order_by('-created_at')[:10]'''
    
    new_query = '''# Get recent signals with related data (exclude backtesting signals)
        recent_signals = TradingSignal.objects.select_related('symbol', 'signal_type').filter(
            is_valid=True
        ).exclude(
            metadata__is_backtesting=True
        ).order_by('-created_at')[:10]'''
    
    content = content.replace(old_query, new_query)
    
    # Update signal_history to exclude backtesting signals
    old_history_query = '''# Get signals with pagination
        signals = TradingSignal.objects.select_related(
            'symbol', 'signal_type'
        ).filter(query).order_by('-created_at')'''
    
    new_history_query = '''# Get signals with pagination (exclude backtesting signals)
        signals = TradingSignal.objects.select_related(
            'symbol', 'signal_type'
        ).filter(query).exclude(
            metadata__is_backtesting=True
        ).order_by('-created_at')'''
    
    content = content.replace(old_history_query, new_history_query)
    
    # Update SignalAPIView to exclude backtesting signals
    old_api_query = '''# Build optimized query with select_related and prefetch_related
            queryset = TradingSignal.objects.select_related(
                'symbol', 'signal_type'
            )'''
    
    new_api_query = '''# Build optimized query with select_related and prefetch_related (exclude backtesting signals)
            queryset = TradingSignal.objects.select_related(
                'symbol', 'signal_type'
            ).exclude(
                metadata__is_backtesting=True
            )'''
    
    content = content.replace(old_api_query, new_api_query)
    
    # Write the updated content
    with open('apps/signals/views.py', 'w') as f:
        f.write(content)
    
    print("âœ… Updated signal views to exclude backtesting signals")


def update_backtesting_service():
    """Update the backtesting service to mark signals as backtesting"""
    print("ğŸ”§ Updating backtesting service...")
    
    # Read the current backtesting service
    with open('apps/signals/strategy_backtesting_service.py', 'r') as f:
        content = f.read()
    
    # Update the signal creation to mark as backtesting
    old_metadata = '''metadata=signal.get('strategy_details', {})'''
    
    new_metadata = '''metadata={
                    **signal.get('strategy_details', {}),
                    'is_backtesting': True,
                    'signal_source': 'BACKTESTING'
                }'''
    
    content = content.replace(old_metadata, new_metadata)
    
    # Write the updated content
    with open('apps/signals/strategy_backtesting_service.py', 'w') as f:
        f.write(content)
    
    print("âœ… Updated backtesting service to mark signals")


def create_backtesting_signals_view():
    """Create a separate view for backtesting signals"""
    print("ğŸ“Š Creating backtesting signals view...")
    
    backtesting_view = '''
@login_required
def backtesting_signals_history(request):
    """Backtesting signals history view - shows only backtesting signals"""
    try:
        # Get query parameters
        symbol = request.GET.get('symbol', '')
        signal_type = request.GET.get('signal_type', '')
        page = int(request.GET.get('page', 1))
        per_page = int(request.GET.get('per_page', 50))
        
        # Build query - show only backtesting signals
        query = Q()
        
        # Filter by symbol
        if symbol:
            query &= Q(symbol__symbol__icontains=symbol)
        
        # Filter by signal type
        if signal_type:
            query &= Q(signal_type__name__icontains=signal_type)
        
        # Show only backtesting signals
        query &= Q(metadata__is_backtesting=True)
        
        # Get signals with pagination
        signals = TradingSignal.objects.select_related(
            'symbol', 'signal_type'
        ).filter(query).order_by('-created_at')
        
        # Calculate pagination
        total_signals = signals.count()
        start_index = (page - 1) * per_page
        end_index = start_index + per_page
        signals_page = signals[start_index:end_index]
        
        # Transform signals to match template expectations
        processed_signals = []
        for signal in signals_page:
            # Calculate performance if executed
            is_profitable = None
            performance_percentage = None
            
            if signal.is_executed and signal.execution_price and signal.target_price:
                if signal.signal_type.name == 'BUY':
                    performance = ((float(signal.target_price) - float(signal.execution_price)) / float(signal.execution_price)) * 100
                else:  # SELL
                    performance = ((float(signal.execution_price) - float(signal.target_price)) / float(signal.execution_price)) * 100
                
                is_profitable = performance > 0
                performance_percentage = round(performance, 2)
            
            signal_data = {
                'id': signal.id,
                'symbol': signal.symbol.symbol,
                'symbol_name': signal.symbol.name,
                'signal_type': signal.signal_type.name,
                'signal_type_color': signal.signal_type.color,
                'strength': signal.strength,
                'confidence_score': signal.confidence_score,
                'confidence_level': signal.confidence_level,
                'entry_price': signal.entry_price,
                'target_price': signal.target_price,
                'stop_loss': signal.stop_loss,
                'risk_reward_ratio': signal.risk_reward_ratio,
                'timeframe': signal.timeframe,
                'entry_point_type': signal.entry_point_type,
                'quality_score': signal.quality_score,
                'is_valid': signal.is_valid,
                'expires_at': signal.expires_at,
                'technical_score': signal.technical_score,
                'sentiment_score': signal.sentiment_score,
                'news_score': signal.news_score,
                'volume_score': signal.volume_score,
                'pattern_score': signal.pattern_score,
                'economic_score': signal.economic_score,
                'sector_score': signal.sector_score,
                'is_executed': signal.is_executed,
                'executed_at': signal.executed_at,
                'execution_price': signal.execution_price,
                'is_profitable': is_profitable,
                'profit_loss': signal.profit_loss,
                'performance_percentage': performance_percentage,
                'analyzed_at': signal.analyzed_at,
                'notes': signal.notes,
                'created_at': signal.created_at,
                'updated_at': signal.updated_at,
                'is_backtesting': True,  # Mark as backtesting signal
            }
            processed_signals.append(signal_data)
        
        # Get unique values for filters
        unique_signal_types = list(TradingSignal.objects.filter(
            metadata__is_backtesting=True
        ).values_list('signal_type__name', flat=True).distinct().exclude(signal_type__name__isnull=True))
        
        # Pagination info
        total_pages = (total_signals + per_page - 1) // per_page
        has_prev = page > 1
        has_next = page < total_pages
        
        # Calculate page range for pagination
        start_page = max(1, page - 2)
        end_page = min(total_pages, page + 2)
        page_range = range(start_page, end_page + 1)
        
        context = {
            'signals': processed_signals,
            'total_count': total_signals,
            'total_pages': total_pages,
            'page': page,
            'per_page': per_page,
            'has_prev': has_prev,
            'has_next': has_next,
            'page_range': page_range,
            'unique_signal_types': unique_signal_types,
            'current_filters': {
                'symbol': symbol,
                'signal_type': signal_type,
            },
            'is_backtesting_view': True,
        }
        
        return render(request, 'signals/backtesting_history.html', context)
        
    except Exception as e:
        logger.error(f"Error rendering backtesting signals history: {e}")
        return render(request, 'signals/backtesting_history.html', {'error': str(e)})
'''
    
    # Add the view to the views file
    with open('apps/signals/views.py', 'r') as f:
        content = f.read()
    
    # Add the new view before the last function
    content = content.replace(
        '@login_required\ndef duplicate_signals_dashboard(request):',
        backtesting_view + '\n\n@login_required\ndef duplicate_signals_dashboard(request):'
    )
    
    # Write the updated content
    with open('apps/signals/views.py', 'w') as f:
        f.write(content)
    
    print("âœ… Created backtesting signals view")


def update_urls():
    """Add URL for backtesting signals"""
    print("ğŸ”— Adding backtesting signals URL...")
    
    # Read the current URLs
    with open('apps/signals/urls.py', 'r') as f:
        content = f.read()
    
    # Add the new URL
    new_url = "    path('backtesting-history/', views.backtesting_signals_history, name='backtesting_signals_history'),"
    
    content = content.replace(
        "    path('duplicates/', views.duplicate_signals_dashboard, name='duplicate_signals_dashboard'),",
        "    path('duplicates/', views.duplicate_signals_dashboard, name='duplicate_signals_dashboard'),\n" + new_url
    )
    
    # Write the updated content
    with open('apps/signals/urls.py', 'w') as f:
        f.write(content)
    
    print("âœ… Added backtesting signals URL")


def main():
    """Main function"""
    print("ğŸš€ Separating Backtesting Signals")
    print("=" * 50)
    
    # Step 1: Mark existing backtesting signals
    mark_backtesting_signals()
    
    # Step 2: Update signal views to exclude backtesting signals
    update_signal_views()
    
    # Step 3: Update backtesting service to mark new signals
    update_backtesting_service()
    
    # Step 4: Create separate backtesting signals view
    create_backtesting_signals_view()
    
    # Step 5: Add URL for backtesting signals
    update_urls()
    
    print("\nâœ… Backtesting signals separation completed!")
    print("ğŸ“Š Main signals page now excludes backtesting signals")
    print("ğŸ” Backtesting signals available at: /signals/backtesting-history/")


if __name__ == '__main__':
    main()
